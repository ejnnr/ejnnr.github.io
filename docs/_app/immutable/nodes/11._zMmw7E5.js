import{t as E,a as J}from"../chunks/ZND8Q6sY.js";import"../chunks/D1wvszJw.js";import{s as n,f as Y,c as a,b as s,n as L}from"../chunks/CXEaPN9q.js";import{h as e}from"../chunks/CkMDHBy_.js";import{l as U,s as V}from"../chunks/lNFSlT5-.js";import{_ as Z}from"../chunks/BInqBSHA.js";const v={title:"Einsum is easy and useful",summary:"`einsum` is one of the most useful functions in Numpy/Pytorch/Tensorflow and yet many people don't use it. It seems to have a reputation as being difficult to understand and use, which is completely backwards in my view: the reason `einsum` is great is precisely because it is *easier* to use and reason about than the alternatives. So this post tries to set the record straight and show how simple `einsum` really is.\n  ",date:"2022-11-05T00:00:00.000Z",tags:[],draft:!1,image:{preview_only:"true"}},{title:en,summary:tn,date:on,tags:pn,draft:cn,image:un}=v;var G=E(`<p><code>einsum</code> is one of the most useful functions in Numpy/Pytorch/Tensorflow and yet many people don’t use it. It seems to have a reputation as being difficult to understand and use, which is completely backwards in my view: the reason <code>einsum</code> is great is precisely because it is <em>easier</em> to use and reason about than the alternatives. So this post tries to set the record straight and show how simple <code>einsum</code> really is.</p> <p>The general syntax for <code>einsum</code> is</p> <pre class="language-python"><!></pre> <p>with an arbitrary number of tensors after the string. (I’ll be saying “tensors” but they could just as well be Numpy arrays.)</p> <p>Let’s look at an example. Say we have two matrices, <code>A</code> and <code>B</code>, with shapes such that we can multiply them as <code>A @ B</code>. Using <code>einsum</code>, we can write this matrix product as</p> <pre class="language-python"><!></pre> <p>The interesting part is the string, <code>"ij,jk-&gt;ik"</code>. These <code>einsum</code> strings always follow the same structure:</p> <pre class="language-python"><!></pre> <p>In this example, the input indices are <code>"ij,jk"</code>. These <em>define</em> letters for indices into each input tensor. Different tensors are comma-separated, so <code>ij</code> refers to <code>A</code> and <code>jk</code> refers to <code>B</code>. <code>ij</code> means we call the first axis of <code>A</code> <code>i</code> and the second axis <code>j</code>, and similarly, <code>jk</code> defines names for the axes of <code>B</code>. The specific letters we use are arbitrary here, we could just as well write <code>"ga,aw-&gt;gw"</code>. There has to be one index per axis of the input tensor—in our case, both <code>A</code> and <code>B</code> have two axes (they’re matrices), so both get two indices.</p> <p>What’s important is that we’re using the same letter, <code>j</code>, both for the second axis of <code>A</code> and for the first axis of <code>B</code>. That’s <em>not</em> just an arbitrary definition, it has an effect on the result! Think of it this way: the entire left-hand side, <code>"ij,jk"</code> defines a three-dimensional tensor, indexed by <code>i</code>, <code>j</code>, and <code>k</code>. We get its elements by <em>multiplying</em> the corresponding elements of <code>A</code> and <code>B</code>:</p> <pre class="language-python"><!></pre> <p>So it matters that <code>j</code> appears twice—a string like <code>"ij,lk"</code> would define a four-dimensional tensor:</p> <pre class="language-python"><!></pre> <p>(Don’t worry about the order of these indices into <code>product</code>—as we’ll see in a moment, the right-hand side of our string will explicitly specify the order we want).</p> <p>The right side of the <code>-&gt;</code> arrow describes how to get our final output from this <code>product</code> tensor. It’s very simple: any index that appears on the left (i.e. in the <code>product</code> tensor) but doesn’t appear on the right is summed over. So in our matrix multiplication example, since our output indices are <code>ik</code>, we sum over <code>j</code>. So the final result is</p> <pre class="language-python"><!></pre> <p>Precisely a matrix multiply, as promised!</p> <p>All of this generalizes in very nice and intuitive ways. On the left side of the <code>-&gt;</code> arrow, we can have arbitrary patterns, and they’ll always describe a scheme for indexing into a product of the inputs. For example, the string <code>"iij,kji,l"</code> would define a four-dimensional tensor, given by</p> <pre class="language-python"><!></pre> <p>(for input tensors <code>A</code>, <code>B</code>, <code>C</code>).
Note how much easier this is compared to a version without <code>einsum</code>:</p> <pre class="language-python"><!></pre> <p>Our output can now be any permutation of any subset of <code>ijkl</code>. For example, <code>"iij,kji,l-&gt;ki"</code> would implicitly compute the product tensor above, then sum over <code>j</code> and <code>l</code>, and finally permute the result so the order of axes was <code>ki</code>. Contrast with how messy this would be without <code>einsum</code>:</p> <pre class="language-python"><!></pre> <p>The main point is not that the <code>einsum</code> version is shorter—the point is that the other version took me 10 minutes to write and I’m still not sure it’s correct.</p> <p>That concludes the description of <code>einsum</code>, but let’s look at some more examples to get a better intuition:</p> <ul><li>Say you want to compute the <em>transpose</em> of the matrix product, <code>(A @ B).T</code>. What that means is just that you want the indices in the output flipped, so the string now becomes <code>"ij,jk-&gt;ki"</code>.</li> <li>Sometimes you want to sum over <em>all</em> axes; in that case, you can just leave the right hand side empty. For example, <code>"i,i-&gt;"</code> will compute the inner product of two input vectors.</li> <li>Just like you can have repeated indices in different input tensors, you can repeat indices within the same tensor. For example, <code>"ii-&gt;"</code> computes the trace of a matrix. Or you could do <code>"ii-&gt;i"</code> to get the diagonal as a vector.</li> <li>You can trivially add batch dimensions to any operation. For example, a batched inner product would be <code>"bi,bi-&gt;b"</code>. A batched matrix multiply would be <code>"bij,bjk-&gt;bik"</code>. If for some reason, your batch dimension is in the last position for the second batch of matrices, that’s no problem: <code>"bij,jkb-&gt;bik"</code>.</li> <li>Batching also lets you take arbitrary diagonals of a tensor easily. For example, <code>"ibi-&gt;bi"</code> will give you the diagonal along the first and third axis, batched over the middle axis.</li> <li>A neat trick is that you can have a <em>variable</em> number of batch dimensions using a <code>...</code> syntax: <code>"...ij,...jk-&gt;...ik"</code> is a batched matrix multiply that works for any number of batch dimensions. The <code>...</code> can be anywhere, not just at the front. For example, <code>"...ij,j...k-&gt;ik..."</code> will work just fine, for any number of dimensions as the <code>...</code></li></ul> <h1>Einops</h1> <p>The main problem with <code>einsum</code> is that it doesn’t support enough operations. For example, say you have an image tensor <code>x</code> with shape <code>(batch, channels, height, width)</code>. If all you want to do is move the channel axis, you can just do</p> <pre class="language-python"><!></pre> <p>But what if you also want to flatten the height and width dimension into a single axis? That’s where the <a href="http://einops.rocks" rel="nofollow"><code>einops</code></a> library comes into play:</p> <pre class="language-python"><!></pre> <p>The <code>rearrange</code> function takes a tensor followed by a string similar to <code>einsum</code> strings. The only new aspect are the parentheses—here, they tell <code>einops</code> to combine the height and width dimension into one axis. Just like <code>einsum</code>, <code>rearrange</code> is extremely flexible, so you can for example transpose these axes before flattening them just by doing</p> <pre class="language-python"><!></pre> <p>You can also have parentheses on the left side, to split one axis into multiple. So for example, we can invert the operation above using</p> <pre class="language-python"><!></pre> <p>The <code>h=32</code> tells <code>einops</code> that the <code>h</code> axis should have length 32 (without this information, it would be unclear how to split up the single input axis).</p> <p>Note how <em>obvious</em> it is that <code>"b (w h) c -&gt; b c h w"</code> is the inverse of <code>"b c h w -&gt; b (w h) c"</code>. We just switched the left and right-hand side! In general, you can <em>compose</em> <code>rearrange</code> operations: doing <code>"string_1 -&gt; string_2"</code> followed by <code>"string_2 -&gt; string_3"</code> is the same as doing <code>"string_1 -&gt; string_3"</code>.</p> <p>There’s more to say about <code>rearrange</code>, and its cousin <code>repeat</code>, but the <code>einops</code> documentation does a good job explaining them, so I’ll leave it at that.</p> <h1>A more complex example</h1> <p>As a final example, let’s consider a multi-head attention mechanism. Say we have our <code>Q</code>, <code>K</code> and <code>V</code> tensors,
each of shape <code>(batch, seq_length, n_heads * head_dim)</code> (the <code>n_heads</code> and <code>head_dim</code> dimensions are flattened into one because we did a single matrix multiply for all heads to obtain these tensors). We want to compute the attention pattern <code>A</code> of shape <code>(batch, n_heads, seq_length, seq_length)</code>. We can use <code>einops</code> and <code>einsum</code>:</p> <pre class="language-python"><!></pre> <p>Note how simple this is: the output of our rearranged tensors, <code>bqhd</code> and <code>bkhd</code>, already tell us what the inputs for the <code>einsum</code> have to be. The output indices for the <code>einsum</code> are almost determined by the desired output shape. Implicitly, this is a batched matrix multiply over the <code>d</code> dimensions (batched over all other axes), but we don’t have to think about that to write down the <code>einsum</code>.</p> <p>Contrast with this alternative, where we have to carefully think about the position of each axis:</p> <pre class="language-python"><!></pre> <p><code>einsum</code> isn’t just easier to read and write, it’s also easier to refactor. Imagine we suddenly have to deal with multiple batch dimensions. In the <code>einsum</code> version, we just replace the <code>b</code> with <code>...</code> and everything works, whereas the second version becomes even messier. Or imagine the format of our tensors changes so that the <code>h</code> and <code>d</code> axes are now swapped. In the <code>einsum</code> version, we just swap all occurrences of <code>h</code> and <code>d</code>. The other version requires us to carefully check all the magic numbers to see which ones need to be changed.</p> <h1><code>einsum</code> could be even better</h1> <p>I’d love to see an <code>einsum</code> wrapper that combines the capabilities of <code>einsum</code> and <code>rearrange</code>. For example, we could write the attention mechanism above as a simple one-liner:</p> <pre class="language-python"><!></pre> <p>If anyone ends up implementing this, please <a href="mailto:erik@ejenner.com">let me know</a>!</p>`,1);function ln(_,x){const j=U(x,["children","$$slots","$$events","$$legacy"]);Z(_,V(()=>j,v,{children:(A,H)=>{var w=G(),t=n(Y(w),4),T=a(t);e(T,()=>'<code class="language-python">einsum<span class="token punctuation">(</span><span class="token string">"some string describing an operation"</span><span class="token punctuation">,</span> tensor_1<span class="token punctuation">,</span> tensor_2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></code>'),s(t);var o=n(t,6),B=a(o);e(B,()=>'<code class="language-python">einsum<span class="token punctuation">(</span><span class="token string">"ij,jk->ik"</span><span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">)</span></code>'),s(o);var p=n(o,4),N=a(p);e(N,()=>'<code class="language-python"><span class="token string">"&lt;input indices> -> &lt;output indices>"</span></code>'),s(p);var c=n(p,6),I=a(c);e(I,()=>'<code class="language-python">product<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>j<span class="token punctuation">,</span> k<span class="token punctuation">]</span></code>'),s(c);var i=n(c,4),q=a(i);e(q,()=>'<code class="language-python">product<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> l<span class="token punctuation">,</span> k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>l<span class="token punctuation">,</span> k<span class="token punctuation">]</span></code>'),s(i);var u=n(i,6),$=a(u);e($,()=>'<code class="language-python">out<span class="token punctuation">[</span>i<span class="token punctuation">,</span> k<span class="token punctuation">]</span> <span class="token operator">=</span> sum_j A<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>j<span class="token punctuation">,</span> k<span class="token punctuation">]</span></code>'),s(u);var l=n(u,6),S=a(l);e(S,()=>'<code class="language-python">product<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> l<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>k<span class="token punctuation">,</span> j<span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">*</span> C<span class="token punctuation">[</span>l<span class="token punctuation">]</span></code>'),s(l);var r=n(l,4),F=a(r);e(F,()=>`<code class="language-python">n <span class="token operator">=</span> A<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
product <span class="token operator">=</span> A<span class="token punctuation">[</span>t<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>         <span class="token operator">*</span> B<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>         <span class="token operator">*</span> C<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span></code>`),s(r);var d=n(r,4),Q=a(d);e(Q,()=>`<code class="language-python"><span class="token comment"># With broadcasting and array indexing:</span>
n <span class="token operator">=</span> A<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
out <span class="token operator">=</span> <span class="token punctuation">(</span>
    A<span class="token punctuation">[</span>t<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>
  <span class="token operator">*</span> B<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>
  <span class="token operator">*</span> C<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>T

<span class="token comment"># With einsum:</span>
out <span class="token operator">=</span> t<span class="token punctuation">.</span>einsum<span class="token punctuation">(</span><span class="token string">"iij,kji,l->ki"</span><span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span></code>`),s(d);var h=n(d,12),K=a(h);e(K,()=>'<code class="language-python">einsum<span class="token punctuation">(</span><span class="token string">"bchw->bhwc"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span></code>'),s(h);var k=n(h,4),W=a(k);e(W,()=>'<code class="language-python">rearrange<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">"b c h w -> b (h w) c"</span><span class="token punctuation">)</span></code>'),s(k);var m=n(k,4),C=a(m);e(C,()=>'<code class="language-python">rearrange<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">"b c h w -> b (w h) c"</span><span class="token punctuation">)</span></code>'),s(m);var g=n(m,4),O=a(g);e(O,()=>'<code class="language-python">rearrange<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">"b (w h) c -> b c h w"</span><span class="token punctuation">,</span> h<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span></code>'),s(g);var b=n(g,12),P=a(b);e(P,()=>`<code class="language-python">Q <span class="token operator">=</span> rearrange<span class="token punctuation">(</span>Q<span class="token punctuation">,</span> <span class="token string">"b q (h d) -> b q h d"</span><span class="token punctuation">,</span> h<span class="token operator">=</span>n_heads<span class="token punctuation">)</span>
K <span class="token operator">=</span> rearrange<span class="token punctuation">(</span>K<span class="token punctuation">,</span> <span class="token string">"b k (h d) -> b k h d"</span><span class="token punctuation">,</span> h<span class="token operator">=</span>n_heads<span class="token punctuation">)</span>
A <span class="token operator">=</span> einsum<span class="token punctuation">(</span><span class="token string">"b q h d, b k h d -> b h q k"</span><span class="token punctuation">,</span> Q<span class="token punctuation">,</span> K<span class="token punctuation">)</span></code>`),s(b);var y=n(b,6),z=a(y);e(z,()=>`<code class="language-python">batch<span class="token punctuation">,</span> seq_length<span class="token punctuation">,</span> _ <span class="token operator">=</span> Q<span class="token punctuation">.</span>shape
Q <span class="token operator">=</span> Q<span class="token punctuation">.</span>view<span class="token punctuation">(</span>batch<span class="token punctuation">,</span> seq_length<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n_heads<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
K <span class="token operator">=</span> K<span class="token punctuation">.</span>view<span class="token punctuation">(</span>batch<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> seq_length<span class="token punctuation">,</span> n_heads<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
A <span class="token operator">=</span> <span class="token punctuation">(</span>Q @ K<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>moveaxis<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></code>`),s(y);var f=n(y,8),D=a(f);e(D,()=>'<code class="language-python">A <span class="token operator">=</span> einsum<span class="token punctuation">(</span><span class="token string">"b q (h d), b k (h d) -> b h q k"</span><span class="token punctuation">,</span> Q<span class="token punctuation">,</span> K<span class="token punctuation">,</span> h<span class="token operator">=</span>n_heads<span class="token punctuation">)</span></code>'),s(f),L(2),J(A,w)},$$slots:{default:!0}}))}export{ln as component};
